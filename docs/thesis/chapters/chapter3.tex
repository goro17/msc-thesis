\chapter{Survey of common CRDT implementation and frameworks}

This chapter provides a systematic survey of Conflict-free Replicated Data Type (CRDT)
implementations documented in academic literature, examining how data structures of
varying complexity -- registers, counters, sets, maps, lists -- are designed to achieve
state convergence. Each data structure is supported by a set of semantics that model the
system's behavior in the face of concurrent operations.

We then conclude with an examination of a few production-grade CRDT frameworks tailored
for general use, such as \textit{Automerge} and \textit{Yjs}, and illustrate their
underlying algorithmic foundations, bridging theoretical formulations with practical
distributed systems engineering. The latter will also constitute the backbone of the
Proof-of-Concept we will discuss in the following chapter.

\section{Registers}

A \textit{register} is an object that holds an opaque value, that supports a
\textit{write} operation to update its value, and a \textit{read} operation to query it.
Concurrent operations writing to the same register require safeguard measures to be
adopted, which comes in the form of two rules, each supporting their own CRDT
implementation, the \textit{Last-Writer-Wins Register} (LWW-Register) and the
\textit{Multi-Value Register} (MV-Register) \cite{shapiro2011comprehensive}.

\subsection{Last-Writer-Wins Register (LWW-Register)}

The LWW-Register represents the simplest form CRDT implementation. It is formed by a
single value, with a timestamp associated to it; the timestamp's presence is due to how
the \textit{last-writer-wins} rule is applied. Given two conflicting states, $s_1$ and
$s_2$, which are affected by concurrent updates, the CRDT's \textit{merge} operation is
applied as follows: $$\text{merge}(s_1,s_2) = \text{max}(s_1\text{.timestamp},
s_2\text{.timestamp})$$

\begin{algorithm}[b!]
\caption{State-based Last-Writer-Wins Register (LWW-Register)}
\label{alg:lww-register}
\begin{algorithmic}[1]
\State let state $s:=$ (value $x$, timestamp $t$)\Comment{initially $(\perp, 0)$}

\Procedure{update}{value $x'$}
    \State $s.x = x'$
    \State $s.t = now()$
\EndProcedure
\Procedure{query}{ }
    \State\Return $s.x$
\EndProcedure
\Procedure{compare}{states $s$, $s''$}
    \If{$s.t\leq s'.t$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{states $s$, $s'$}
    \State let state $s'' := (\perp,0)$
    \If{$s\leq s'$}\Comment{\Call{compare}{$s,s'$}}
        \State $s''.x,s''.t = s'.x,s'.t$
    \Else
        \State $s''.x,s''.t = s.x,s.t$
    \EndIf
    \State\Return s''
\EndProcedure
\end{algorithmic}
\end{algorithm}

The merge operation compares the timestamp from each update and retains the
replica with the highest timestamp. This forms a semilattice where the partial
order is defined by timestamp comparison, ensuring deterministic convergence regardless
of message delivery order. A high-level state-based LWW-Register
\cite{shapiro2011comprehensive} implementation can be found in specification
\ref{alg:lww-register}.


\subsection{Multi-Value Register (MV-Register)}

Made popular by Amazon's Dynamo \cite{decandia2007dynamo} key-value store, Multi-Value
Register CRDTs take a different approach to concurrency with respect to the LWW-Register.
Rather than discarding values based on their timestamp, MV-Registers maintain all
concurrently written values. In this case, the payload is formed by a set
$S$ of values, each with their associated causal context (e.g., vector clock or version
vector).

\begin{algorithm}[bt!]
\caption{State-based Multi-Value Register (MV-Register)}
\label{alg:mv-register}
\begin{algorithmic}[1]
\State let state $s:=$ set $X$\Comment{
    $X$: set of $(x, V)$ pairs of value $x$ and version vector $V$
    (initially, $\{(\perp,[0,..,0])\}$)
}

\Procedure{update}{set $R$}
    \State let $V' :=$ \Call{increaseVersionVector}{ }
    \State $s.X = R \times \{V'\}$
\EndProcedure
\Procedure{query}{ }
    \State\Return $r.X$
\EndProcedure
\Procedure{compare}{sets $A$, $B$}
    \If{$(\forall(x,V) \in A, (x',V') \in B: V \leq V')$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{sets $A$, $B$}
    \State let $A' := \{(x,V)\in A|\forall(y,W)\in B: V||W \vee V \geq W\}$
    \State let $B' := \{(y,W)\in B|\forall(x,V)\in A: W||V \vee W \geq V\}$
    \State let $C := A \cup B$
    \State\Return $C$
\EndProcedure
\end{algorithmic}
\end{algorithm}

As shown in specification \ref{alg:mv-register}, the \textit{query} operation returns a
copy of the payload, while the \textit{update} operation overwrites it by associating the
value to a "fresh" version vector that dominates all previous ones. The \textit{merge}
operation returns the union. Compared to its LWW-Register counterpart, the \textit{merge}
operation acts by preserving all concurrent values in the set
\cite{shapiro2011comprehensive} -- in other words, a merge between two conflicting sets
returns a union of every element in each input set whose version vector is not dominated
by the one associated to an element in the other input set.


\section{Counters}

A \textit{counter} is an integer object supporting both \textit{increment} and
\textit{decrement} operations to update its value, and a \textit{read} operation to query
the current value. Trivially, we can construct an operation-based counter CRDT in its
simplest form by propagating update operations as-is. Given that both addition and
subtraction operations commute, the delivery order of concurrent operations is
irrelevant for achieving convergence \cite{shapiro2011comprehensive} -- as long as no
overflow is caused by such operation.

\subsection{Grow-only Counter (G-Counter)}

The simplest form of state-based counter CRDT is the \textit{G-Counter}, which only
supports \textit{increment} operations. For this purpose, each replica $i$ maintains a
vector $V[1..n]$, where $V[i]$ represents the local increment count and $V[j]$ (for
$j \neq i$) represents the last known count from replica $j$
\cite{shapiro2011comprehensive}. This implementation is shown in specification
\ref{alg:g-counter}.

\begin{algorithm}[bt!]
\caption{State-based Grow-only Counter (G-Counter)}
\label{alg:g-counter}
\begin{algorithmic}[1]
\State let state $s:=$ vector $V[i_1,..,i_n]$ (where $n$: number of replicas)
    \Comment{initally, $[0,..,0]$}
\Procedure{increment}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $V[g]=V[g]+1$
\EndProcedure
\Procedure{query}{ }
    \State\Return $\sum_i V[i]$
\EndProcedure
\Procedure{compare}{vectors $X$, $Y$}
    \If{$\forall i \in [0,n-1]: X[i] \leq Y[i]$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{vectors $X$, $Y$}
    \State let vector $Z := [0,..,0]$
    \State $\forall i \in [0,n-1]: Z[i] = \text{max}(X[i],Y[i])$
    \State\Return Z
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Positive-Negative Counter (PN-Counter)}

In effort to support decrement operations, the PN-Counter is designed by combining two
G-Counters. This CRDT's implementation is therefore formed by a compound payload of two
integer vectors, one to keep track of increments ($P$), while the other to keep track of
decrements ($N$) \cite{shapiro2011comprehensive}.

\begin{algorithm}[bt!]
\caption{State-based Positive-Negative Counter (PN-Counter)}
\label{alg:pn-counter}
\begin{algorithmic}[1]
\State let state $s:=$ Payload $(P[i_1,..,i_n],N[i_1,..,i_n])$ (where $n$: number of replicas)
    \Comment{initally, $([0,..,0],[0,..,0])$}
\Procedure{increment}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $P[g]=P[g]+1$
\EndProcedure
\Procedure{decrement}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $N[g]=N[g]+1$
\EndProcedure
\Procedure{query}{ }
    \State\Return $\sum_i P[i] - \sum_i N[i]$
\EndProcedure
\Procedure{compare}{payloads $X$, $Y$}
    \If{
        $\forall i \in [0,n-1]: X.P[i] \leq Y.P[i] 
         \wedge \forall i \in [0,n-1]: X.N[i] \leq Y.N[i]$
    }
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{payloads $X$, $Y$}
    \State let payload $Z := ([0,..,0],[0,..,0])$
    \State $\forall i \in [0,n-1]: Z.P[i] = \text{max}(X.P[i],Y.P[i])$
    \State $\forall i \in [0,n-1]: Z.N[i] = \text{max}(X.N[i],Y.N[i])$
    \State\Return Z
\EndProcedure
\end{algorithmic}
\end{algorithm}

Specification \ref{alg:pn-counter} illustrates this state-based implementation, with
\textit{increment} and \textit{decrement} operations affecting separate vectors of the
state's payload. The \textit{query} operation returns the counter's value by computing
the difference between the $P$ and $N$ vectors, while the \textit{merge} operation
independently merges the two vectors through component-wise maximum.

\section{Sets}

A \textit{set} is a container for an arbitrary number of elements. It provides updates
in the form of \textit{add} and \textit{remove} operations, which respectively add or
remove a given element to or from the set, plus a \textit{lookup} operation that checks
whether a given element $e$ belongs to the set. Several concurrency semantics are viable
in the presence of concurrent insertion and removal operations on the same element.

\subsection{Grow-only Set (G-Set)}
The simplest implementation of a set CRDT is to only permit \textit{add} operations,
which is made possible by employing an union of all added elements. Since the union
operation is commutative, the operation-based implementation naturally converges,
regardless of delivery order \cite{shapiro2011comprehensive}.

\begin{algorithm}[bt!]
\caption{State-based Grow-only Set (G-Set)}
\label{alg:g-set}
\begin{algorithmic}[1]
\State let state $s:=$ set $A$\Comment{initally, $\varnothing$}
\Procedure{add}{element $e$}
    \State $A = A \cup \{e\}$
\EndProcedure
\Procedure{lookup}{element $e$}
    \If{$(e \in A)$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{compare}{states $s$, $s'$}
    \If{$s.A \subseteq s'.A$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{states $s$, $s'$}
    \State let state $s'' := \varnothing$
    \State $s''.A = s.A \cup s'.A$
    \State\Return $s''$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Specification \ref{alg:g-set} shows the state-based approach, where the \textit{add}
operation modifies the local state through union. A partial order on some state $s$ and
$s'$ can be defined as $s \leq s' \Leftrightarrow s \subseteq s'$. Conversely, the
\textit{merge} operation between two states returns the union of their respective sets.
The G-Set constitutes a basic building block of more complex implementations, such as the
\textit{2P-Set}

\subsection{Two-Phase Set (2P-Set)}

The 2P-Set is an extension of the G-Set with removal capability. It is formed by
combining two G-Sets, which are used to keep track of added and removed elements.

\begin{algorithm}[bt!]
\caption{State-based Two-Phase Set (2P-Set)}
\label{alg:2p-set}
\begin{algorithmic}[1]
\State let state $s:=$ sets $A,R$\Comment{initally, $\{\varnothing,\varnothing\}$}
\Procedure{lookup}{element $e$}
    \If{$(e \in A)$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{add}{element $e$}
    \State $A = A \cup \{e\}$
\EndProcedure
\Procedure{remove}{element $e$}
    \State \textbf{precondition} \Call{lookup}{$e$}
    \State $R = R \cup \{e\}$
\EndProcedure
\Procedure{compare}{states $s$, $s'$}
    \If{$s.A \subseteq s'.A \vee s.R \subseteq s'.R$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{states $s$, $s'$}
    \State let state $s'' := \{\varnothing, \varnothing\}$
    \State $s''.A = s.A \cup s'.A$
    \State $s''.R = s.R \cup s'.R$
    \State\Return $s''$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Specification \ref{alg:2p-set} shows an example of a state-based 2P-Set implementation.
Similar to what occurs with PN-Counters, the two G-Sets of the 2P-Set keep track
separately of \textit{add} and \textit{remove} operations, and the \textit{merge}
operation returns a new state resulting from the union of each set individually.
It is worth noting that a critical issue may arise when a \textit{remove} operation is
attempted for an element $e$ that does not currently exist in the set. As a consequence,
the \textit{remove} operation requires -- as a precondition -- that $e$ already belongs
to the set, before removing it.

\subsection{Last-Writer-Wins element Set (LWW-element-Set)}

An alternative approach to the 2P-Set can be obtained by applying the
\textit{last-writer-wins} semantic. Aside from having separate sets for keeping track of
added and removed elements, each element has a timestamp associated to it. As a
consequence, the \textit{lookup} operation ensures that a given element $e$ is in the set
if it is in $A$ and it is not in $R$ with a higher timestamp
\cite{shapiro2011comprehensive}:
$$lookup(e) = \exists t, \forall t' > t: (e,t) \in A \wedge (e,t') \notin R$$

\subsection{Observed-Remove Set (OR-Set)}

A more intuitive construction of set CRDT can be obtained by considering
\textit{add-wins} semantics. Simply put, a situation in which an \textit{add} and a
\textit{remove} operation on the same element $e$ occur concurrently results in the
outcome of $e$ being in the set \cite{shapiro2011conflict} -- \textit{add($e$)} "wins"
over \textit{remove($e$)}.

For the \textit{OR-Set}, this means that concurrency strictly depends on causal delivery.
An operation that cancels another will cancel the operations in its causal past, but not
the ones that are being concurrently issued \cite{almeida2024crdts}.

\begin{algorithm}
    \floatname{specification}{Specification}
    \caption{Op-based Observed-Remove Set (OR-Set)}\label{alg:or-set}
    \begin{algorithmic}[1]
        \State let state $s$ := set $S$ of pairs $(\text{element }e,\text{unique ID }U)$
        \Comment{initially, $\varnothing$}
        \Procedure{lookup}{element $e$}
            \If{$\exists U: (e, U)\in S$}
                \State\Return true
            \Else
                \State\Return false
            \EndIf
        \EndProcedure
        \Procedure{add}{element $e$}
            \State \textbf{prepare} ($e$)
                \State\hspace{\algorithmicindent}
                let $\alpha = unique()$\Comment{$unique()$ returns an unique ID}
            \State \textbf{effect} ($e,\alpha$)
                \State\hspace{\algorithmicindent}
                $S = S \cup \{(e,\alpha)\}$
        \EndProcedure
        \Procedure{remove}{element $e$}
            \State \textbf{prepare} ($e$) 
                \State\hspace{\algorithmicindent}
                \textbf{precondition} \Call{lookup}{$e$}
                \State\hspace{\algorithmicindent}
                let $R = \{(e,U)|\exists U: (e,U)\in S\}$
            \State \textbf{effect}($R$)
                \State\hspace{\algorithmicindent}
                \textbf{precondition}
                $\forall(e,U)\in R: add(e,U)\text{ has been delivered}$
                \State\hspace{\algorithmicindent}
                $S = S \setminus R$\Comment{remove pairs observed at source}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

Specification \ref{alg:or-set} illustrates an op-based implementation of OR-Set CRDT,
where the \textit{add} operation always ensures to add an element to the set associating
it with a fresh unique identifier $U$. This ensures that the \textit{remove} operation is
capable of retrieving all unique identifiers associated to the element $e$ which is
target of removal -- more precisely, all the unique identifiers for the element $e$ that
are causally observed at the source replica -- and issue removal for those specific
entries, ensuring preservation of causality \cite{shapiro2011comprehensive}. The unique
tagging ensures that concurrent adds create distinct entries.


\section{Maps}

A \textit{map} is a data type that maps keys to objects. It typically provides a
$put(k,o)$ operation to associate key $k$ to object $o$, and a $remove(k)$ operation to
that removes the mapping for key $k$. Defining suitable concurrency semantics for maps is
crucial, as decisions must be made regarding the outcome of concurrent \textit{put}
operations for the same key, or concurrent \textit{remove} and \textit{put} operations on
the same key \cite{pregui√ßa2018conflict}.

\subsection{Observed-Remove Map (OR-Map)}

\begin{algorithm}[b!]
    \floatname{specification}{Specification}
    \caption{Op-based Observed-Remove Map (OR-Map)}\label{alg:or-map}
    \begin{algorithmic}[1]
        \State let state $s$ := set $S$ of triplets (key $k$, value $v$, unique ID $U$)
        \Comment{initially, $\varnothing$}
        \Procedure{put}{key $k$, value $v$}
            \State \textbf{prepare} ($k,v$)
                \State\hspace{\algorithmicindent}
                let $\alpha = unique()$\Comment{$unique()$ returns an unique ID}
                \State\hspace{\algorithmicindent}
                let $R = \{(k',v',U')\in S | k'=k\}$
            \State \textbf{effect} ($k,v,\alpha,R$)
                \State\hspace{\algorithmicindent}
                \textbf{precondition}
                $\forall(k,v,U)\in R: put(k,v,U)\text{ has been delivered}$
                \State\hspace{\algorithmicindent}
                $S = (S \setminus R) \cup \{(k,v,\alpha)\}$
                \Comment{Replace elements observed at source by new one}
        \EndProcedure
        \Procedure{remove}{key $k$}
            \State \textbf{prepare} ($k$) 
                \State\hspace{\algorithmicindent}
                let $R = \{(k',v',U') \in S| k'=k\}$
            \State \textbf{effect}($R$)
                \State\hspace{\algorithmicindent}
                \textbf{precondition}
                $\forall(k,v,U)\in R: put(k,v,U)\text{ has been delivered}$
                \State\hspace{\algorithmicindent}
                $S = S \setminus R$\Comment{remove elements observed at source}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

We can define a map CRDT with semantics similar to the ones already observed for OR-Sets.
In this case, the payload is formed by a set of triplets (key $k$, value $v$, unique ID
$U$). The $put(k,v)$ operation associates key $k$ to value $v$, tagging it with a fresh
identifier. $remove(k)$ deletes all existing mappings associated to key $k$.
Specification \ref{alg:or-map} shows an example of a naive op-based implementation
\cite{shapiro2011comprehensive}, where the set of unique identifiers that are un-mapped
in the $remove(k)$ operation are retrieved at the source replica.

\section{Lists (Sequences)}

We will now discuss one of the most complex data types, which is the \textit{list} -- or
\textit{sequence} -- which is essentially a set of elements which are placed in a
precise order. For this purpose, each element in the sequence is associated to a
positional index, and the sequence is sorted according to that same index. Implementing a
suitable CRDT for this type of structure poses a particular challenge, as insertion and
deletion operations for an element affect the positioinal indices of other elements, and
it is crucial to preserve ordering in the face of concurrent modifications.

We will pay close attention to a few list CRDT implementations, as these are well versed
to closely model structured documents in collaborative editing use cases -- and, as such,
serve as a solid foundation to the CRDT frameworks that will be described near  the end
of the chapter.

\subsection{Replicated Growable Array (RGA)}

The \textit{Replicated Growable Array} implements sequence objects in the form of a
linked list. Each node of the list holds an element and an identifier associated to it,
plus a reference to its parent node \cite{Roh2011RGA} -- i.e., the node after which it
was inserted.

Each element's identifier is assumed to be unique and ordered in line with causality
\cite{shapiro2011comprehensive}. For this purpose, a typical identifier is modeled as a
pair formed by a timestamp (e.g., vector clock) and the source replica's identifier.
Namely, given two identifiers $i_1$ and $i_2$, respectively formed by tuples (timestamp
$t_1$, unique ID $U_1$) and (timestamp $t_2$, unique ID $U_2$), $i_1$ is said to
"precede" $i_2$ ($i_1 < i_2$) if $t_1 < t_2$ or if $t_1 = t_2 \wedge U_1 < U_2$
\cite{Briot2016group}.

This definition of precedence is crucial for understanding concurrency semantics for
\textit{insert} operations. In case of two concurrent insertions referencing the same
parent node -- more precisely, two insertions both targeting the position immediately
after the same node -- the logic applied at the remote replica is to place the element
with the highest timestamp after the parent node, and the element with the lowest
timestamp immediately after that.

\begin{figure}[b!]
    \centering
    \includegraphics[width=0.61\linewidth]{diagram-rga.pdf}
    \caption{Example of concurrent insertion in RGA}
    \label{fig:diagram-rga}
\end{figure}

As a practical example of this behavior, consider a system formed by two replicas, with
IDs $0$ and $1$ respectively. Suppose that an element identifier $i$ is denoted in the
form $X.Y$, where $X$ is the operation's timestamp, and $Y$ is the source replica's ID.
For the sake of simplicity, we will consider a set of characters as the payload for the
CRDT. As shown in \autoref{fig:diagram-rga}, the initial state for both replicas is given
by the sequence of characters $\{s,o,d\}$, with identifiers $1.0$, $2.0$, and $3.0$
respectively. Replica $0$ issues operation $ins(2.0,n,4.0)$, while replica $1$ issues
operation $ins(2.0,u,4.1)$. Since both replicas are concurrently attempting an insertion
after character $o$ (identifier $2.0$), they are compared according to the positional
identifier's precedence rules described before. Since $4.1 > 4.0$, this results in
character $u$ being inserted before character $n$. As a consequence, the final state
for both replicas is given by the sequence $\{s,o,u,n,d\}$.

\textit{Delete} operations also require particular attention, since permanently deleting
the same element is considered unsafe -- a concurrent insertion referencing a deleted
node would be unable to correctly locate the insertion position. This can be solved by
marking the target node with a \textit{tombstone} ($\perp$), rather than physically
removing it. When materializing the CRDT's content at a user-facing site, nodes marked
with a tombstone are skipped.

\subsection{WOOT (WithOut Operational Transformation)}

\textit{WOOT} takes a similar approach with respect to RGA. It aims to achieve
consistency by enforcing correctness through \textit{causality}, \textit{convergence},
and \textit{intention preservation} \footnote{Formally, \textit{intention preservation}
means that any operation that has been applied at all replicas will have the same
effects as if it were applied at the originating replica \cite{Sun1998Achieving}.}
\cite{Oster2006WOOT}.

In this case, operations are denoted by the target position's adjacent neighbors --
rather than by an absolute index or reference to a predecessor node, as it occurs in RGA.
For instance, operation $ins(o_x,_y,o_z)$ inserts object $o_y$ after object $o_x$ and
before object $o_x$.

While it is trivial to apply an insertion at the source replica, carefully designing the
insertion integration algorithm at remote replicas represents the heart of WOOT.
For example, suppose we have an ordered sequence of characters, and we would want to
insert character $c$ between characters $c_p$ and $c_n$. The most trivial outcome is
that no other concurrent insertions occur between $c_p$ and $c_n$, resulting in $c$ being
inserted as-is. On the contrary, if two or more characters are inserted between $c_p$ and
$c_n$, the insertion integration requires particular attention and evaluaiton of the
subsequence of characters between $c_p$ and $c_n$, in order to compute a consistent
placement for each character of the subsequence \cite{Oster2006WOOT}.

As it already occurs in RGA, $delete$ operations simply mark the target element with a
tombstone, which requires no additional effort for integration at remote replicas.

\subsection{Logoot}

We now briefly describe another prominent sequence CRDT implementation, provided by the
\textit{Logoot} algorithm. The basic idea is to use a lexicographic order to totally
order the sequence elements \cite{Weiss2009Logoot}. Namely, Logoot employs a unique
identifier allocation strategy, where each element in a sequence is assigned a dense,
totally-ordered position identifier from an unbounded space. These identifiers are
typically constructed in the form of variable-length lists of (integer index, replica ID)
pairs, which enables the insertion of new characters between any two existing positions
without reassigning existing identifiers.

\section{Application Frameworks for general use}

From an application development standpoint, while the CRDTs presented above are useful
for a wide variety of situations -- with the main use case being collaborative editing 
tasks -- their implementation in source code, along with the quirks of the data
structures themselves and/or of the update communication protocol, can be particularly
challenging. In recent years, a few frameworks have emerged and achieved notable success
for providing a "toolbox" of CRDTs ready to use and to integrate in many applications.
Two of the most prominent frameworks are \textit{Yjs} and \textit{Automerge}
\cite{almeida2024crdts}, each of which uses a particular CRDT implementation from
modern literature as a building block to construct more complex data structures. We will
now introduce both of these frameworks, and illustrate the algorithmic foundations
backing each of them.

\subsection{Yjs}

\textit{Yjs} was developed in an effort to bridge the gap in collaborative applications
deployed in peer-to-peer settings, since existing solution at the time -- mostly based on
Operational Transformation -- did not scale well in decentralized environments
\cite{Nicolaescu2015Yjs}. It is a modular framework that provides several common CRDTs,
such as map and array CRDTs, and several tools that enable integration with many
communication protocols and databases. For instance, Yjs includes connection providers
for protocols such as \textit{Websocket}, \textit{WebRTC}, and \textit{Webxdc}, which
can be leveraged for state update propagation, and database providers -- e.g.,
\textit{Redis} -- which can be used to employ e persistent store for CRDTs and updates.

Under the hood, Yjs is essentially an open-source library implementation of the
\textit{YATA} (Yet Another Transformation Approach) protocol, written in the
\textit{JavaScript} language. YATA presents itself as a novel approach to
peer-to-peer shared editing in near real-time, collaborative applications. It aims to
ensure convergence and to preserve user intention for several arbitrary data types
\cite{Nicolaescu2016YATA}, and can easily be integrated with Web and mobile applications.
In order to guarantee cutting-edge P2P concurrency control, YATA utilizes an internal
linked list structure -- taking inspiration from WOOT -- and a set of predefined rules to
enforce a total order on the shared data types. More precisely, linear data structures --
such as text -- is modeled as a doubly-linked list, where each element $e$ references its
\textit{left} ($e_{left}$) and \textit{right} ($e_{right}$) neighbors.

In terms of operation semantics, YATA provides both \textit{insert} and \textit{delete}
operations. The \textit{insert} operation can be denoted as:
$$insert(ID_{op},e_{orig},e_{left},e_{right},isDeleted,content(e))$$

Moreover:

\begin{itemize}
    \item $ID$ is the operation's unique identifier;
    \item $e_{orig}$ references the inserted element's direct predecessor at creation
        time -- i.e., the node in the linked list after which it was originally inserted;
    \item $e_{left}$ and $e_{right}$ reference the previous and the next node in the
        list, respectively;
    \item $isDeleted$ is a flag that marks the element as visible -- or as a tombstone;
    \item $content(e)$ holds the inserted element's payload -- e.g., a character or a
        string.
\end{itemize}

Through this model, YATA aims to guarantee that the inserted element will be placed
somewhere between nodes $e_{left}$ and $e_{right}$. If conflicts arise due to one or more
elements being concurrently placed between the two nodes, a set of ad-hoc resolution
strategies is applied, making sure that all replicas converge to the same state, and that
the user's intention behind the operation itself is preserved.

Being based on the tombstone approach, \textit{delete} operations are straightforward,
and do not have an impact on concurrent insertions or deletions.

Yjs exposes its YATA implementation in the form of a \textit{document}, which is
essentially a container of shared data types -- maps, arrays, sets, and so on. When a
shared data type is affected by one or more changes, it triggers a \textit{transaction},
which generates an update message -- i.e., a delta-state -- that can be shared over the
broadcast channel and seamlessly be merged by remote replicas \cite{yjs_docs}. In
compliance with the decentralized nature of CRDTs, a replica can autonomously apply a
received update to its internal state, and does not require coordination with any
external entity -- e.g., a centralized coordination server.

\subsection{Automerge}

\textit{Automerge} presents itself as a data synchronization and conflict resolution
library, which enables mobile devices to make changes to shared data types
\cite{Kleppmann2018Automerge}, regardless of network topology -- this includes changes
that a device would have made while offline. As the name suggests, changes made on data are
automatically merged to other devices -- this also includes changes made while the local
device was offline.

At its core, Automerge provides a document structure implemented as a CRDT, namely a JSON
(JavaScript Object Notation) data model. Automerge documents are composed of nested maps
and lists or simple values or text sequences \cite{automerge_docs}. They employ simple
merge rules, which are based on RGA, and depend on the specific data type. In general,
conflict resolution is handled arbitrarily, but in such a way that all nodes agree on the
chosen value -- e.g., \textit{last-writer-wins} semantics are applied. Moreover,
Automerge provides the application developer a complete view surrounding the logic which
was applied to resolve a conflict. This means that, although only one of the concurrently
written values shows up in the object's final state, the other values are not lost, but
merely relegated to a list of conflicts appended to the object itself. Through this
approach, Automerge employs both \textit{last-writer-wins} and \textit{multi-value}
semantics.