\chapter{Survey of common CRDT implementation and frameworks}

This chapter provides a systematic survey of Conflict-free Replicated Data Type (CRDT)
implementations documented in academic literature, examining how data structures of
varying complexity -- registers, counters, sets, maps, lists -- are designed to achieve
state convergence. Each data structure is supported by a set of semantics that model the
system's behavior in the face of concurrent operations.

We then conclude with an examination of a few production-grade CRDT frameworks tailored
for general use, such as \textit{Automerge} and \textit{Yjs}, and illustrate their
underlying algorithmic foundations, bridging theoretical formulations with practical
distributed systems engineering. The latter will also constitute the backbone of the
Proof-of-Concept we will discuss in the following chapter.

\section{Registers}

A \textit{register} is an object that holds an opaque value, that supports a
\textit{write} operation to update its value, and a \textit{read} operation to query it.
Concurrent operations writing to the same register require safeguard measures to be
adopted, which comes in the form of two rules, each supporting their own CRDT
implementation, the \textit{Last-Writer-Wins Register} (LWW-Register) and the
\textit{Multi-Value Register} (MV-Register) \cite{shapiro2011comprehensive}.

\subsection{Last-Writer-Wins Register (LWW-Register)}

The LWW-Register represents the simplest form CRDT implementation. It is formed by a
single value, with a timestamp associated to it; the timestamp's presence is due to how
the \textit{last-writer-wins} rule is applied. Given two conflicting states, $s_1$ and
$s_2$, which are affected by concurrent updates, the CRDT's \textit{merge} operation is
applied as follows: $$\text{merge}(s_1,s_2) = \text{max}(s_1\text{.timestamp},
s_2\text{.timestamp})$$

\begin{algorithm}[b!]
\caption{State-based Last-Writer-Wins Register (LWW-Register)}
\label{alg:lww-register}
\begin{algorithmic}[1]
\State let state $s:=$ (value $x$, timestamp $t$)\Comment{initially $(\perp, 0)$}

\Procedure{update}{value $x'$}
    \State $s.x = x'$
    \State $s.t = now()$
\EndProcedure
\Procedure{query}{ }
    \State\Return $s.x$
\EndProcedure
\Procedure{compare}{states $s$, $s''$}
    \If{$s.t\leq s'.t$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{states $s$, $s'$}
    \State let state $s'' := (\perp,0)$
    \If{$s\leq s'$}\Comment{\Call{compare}{$s,s'$}}
        \State $s''.x,s''.t = s'.x,s'.t$
    \Else
        \State $s''.x,s''.t = s.x,s.t$
    \EndIf
    \State\Return s''
\EndProcedure
\end{algorithmic}
\end{algorithm}

The merge operation compares the timestamp from each update and retains the
replica with the highest timestamp. This forms a semilattice where the partial
order is defined by timestamp comparison, ensuring deterministic convergence regardless
of message delivery order. A high-level state-based LWW-Register
\cite{shapiro2011comprehensive} implementation can be found in specification
\ref{alg:lww-register}.


\subsection{Multi-Value Register (MV-Register)}

Made popular by Amazon's Dynamo \cite{decandia2007dynamo} key-value store, Multi-Value
Register CRDTs take a different approach to concurrency with respect to the LWW-Register.
Rather than discarding values based on their timestamp, MV-Registers maintain all
concurrently written values. In this case, the payload is formed by a set
$S$ of values, each with their associated causal context (e.g., vector clock or version
vector).

\begin{algorithm}[bt!]
\caption{State-based Multi-Value Register (MV-Register)}
\label{alg:mv-register}
\begin{algorithmic}[1]
\State let state $s:=$ set $X$\Comment{
    $X$: set of $(x, V)$ pairs of value $x$ and version vector $V$
    (initially, $\{(\perp,[0,..,0])\}$)
}

\Procedure{update}{set $R$}
    \State let $V' :=$ \Call{increaseVersionVector}{ }
    \State $s.X = R \times \{V'\}$
\EndProcedure
\Procedure{query}{ }
    \State\Return $r.X$
\EndProcedure
\Procedure{compare}{sets $A$, $B$}
    \If{$(\forall(x,V) \in A, (x',V') \in B: V \leq V')$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{sets $A$, $B$}
    \State let $A' := \{(x,V)\in A|\forall(y,W)\in B: V||W \vee V \geq W\}$
    \State let $B' := \{(y,W)\in B|\forall(x,V)\in A: W||V \vee W \geq V\}$
    \State let $C := A \cup B$
    \State\Return $C$
\EndProcedure
\end{algorithmic}
\end{algorithm}

As shown in specification \ref{alg:mv-register}, the \textit{query} operation returns a
copy of the payload, while the \textit{update} operation overwrites it by associating the
value to a "fresh" version vector that dominates all previous ones. The \textit{merge}
operation returns the union. Compared to its LWW-Register counterpart, the \textit{merge}
operation acts by preserving all concurrent values in the set
\cite{shapiro2011comprehensive} -- in other words, a merge between two conflicting sets
returns a union of every element in each input set whose version vector is not dominated
by the one associated to an element in the other input set.


\section{Counters}

A \textit{counter} is an integer object supporting both \textit{increment} and
\textit{decrement} operations to update its value, and a \textit{read} operation to query
the current value. Trivially, we can construct an operation-based counter CRDT in its
simplest form by propagating update operations as-is. Given that both addition and
subtraction operations commute, the delivery order of concurrent operations is
irrelevant for achieving convergence \cite{shapiro2011comprehensive} -- as long as no
overflow is caused by such operation.

\subsection{Grow-only Counter (G-Counter)}

The simplest form of state-based counter CRDT is the \textit{G-Counter}, which only
supports \textit{increment} operations. For this purpose, each replica $i$ maintains a
vector $V[1..n]$, where $V[i]$ represents the local increment count and $V[j]$ (for
$j \neq i$) represents the last known count from replica $j$
\cite{shapiro2011comprehensive}. This implementation is shown in specification
\ref{alg:g-counter}.

\begin{algorithm}[bt!]
\caption{State-based Grow-only Counter (G-Counter)}
\label{alg:g-counter}
\begin{algorithmic}[1]
\State let state $s:=$ vector $V[i_1,..,i_n]$ (where $n$: number of replicas)
    \Comment{initally, $[0,..,0]$}
\Procedure{increment}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $V[g]=V[g]+1$
\EndProcedure
\Procedure{query}{ }
    \State\Return $\sum_i V[i]$
\EndProcedure
\Procedure{compare}{vectors $X$, $Y$}
    \If{$\forall i \in [0,n-1]: X[i] \leq Y[i]$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{vectors $X$, $Y$}
    \State let vector $Z := [0,..,0]$
    \State $\forall i \in [0,n-1]: Z[i] = \text{max}(X[i],Y[i])$
    \State\Return Z
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Positive-Negative Counter (PN-Counter)}

In effort to support decrement operations, the PN-Counter is designed by combining two
G-Counters. This CRDT's implementation is therefore formed by a compound payload of two
integer vectors, one to keep track of increments ($P$), while the other to keep track of
decrements ($N$) \cite{shapiro2011comprehensive}.

\begin{algorithm}[bt!]
\caption{State-based Positive-Negative Counter (PN-Counter)}
\label{alg:pn-counter}
\begin{algorithmic}[1]
\State let state $s:=$ Payload $(P[i_1,..,i_n],N[i_1,..,i_n])$ (where $n$: number of replicas)
    \Comment{initally, $([0,..,0],[0,..,0])$}
\Procedure{increment}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $P[g]=P[g]+1$
\EndProcedure
\Procedure{decrement}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $N[g]=N[g]+1$
\EndProcedure
\Procedure{query}{ }
    \State\Return $\sum_i P[i] - \sum_i N[i]$
\EndProcedure
\Procedure{compare}{payloads $X$, $Y$}
    \If{
        $\forall i \in [0,n-1]: X.P[i] \leq Y.P[i] 
         \wedge \forall i \in [0,n-1]: X.N[i] \leq Y.N[i]$
    }
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{payloads $X$, $Y$}
    \State let payload $Z := ([0,..,0],[0,..,0])$
    \State $\forall i \in [0,n-1]: Z.P[i] = \text{max}(X.P[i],Y.P[i])$
    \State $\forall i \in [0,n-1]: Z.N[i] = \text{max}(X.N[i],Y.N[i])$
    \State\Return Z
\EndProcedure
\end{algorithmic}
\end{algorithm}

Specification \ref{alg:pn-counter} illustrates this state-based implementation, with
\textit{increment} and \textit{decrement} operations affecting separate vectors of the
state's payload. The \textit{query} operation returns the counter's value by computing
the difference between the $P$ and $N$ vectors, while the \textit{merge} operation
independently merges the two vectors through component-wise maximum.

\section{Sets}

A \textit{set} is a container for an arbitrary number of elements. It provides updates
in the form of \textit{add} and \textit{remove} operations, which respectively add or
remove a given element to or from the set, plus a \textit{lookup} operation that checks
whether a given element $e$ belongs to the set. Several concurrency semantics are viable
in the presence of concurrent insertion and removal operations on the same element.

\subsection{Grow-only Set (G-Set)}
The simplest implementation of a set CRDT is to only permit \textit{add} operations,
which is made possible by employing an union of all added elements. Since the union
operation is commutative, the operation-based implementation naturally converges,
regardless of delivery order \cite{shapiro2011comprehensive}.

\begin{algorithm}[bt!]
\caption{State-based Grow-only Set (G-Set)}
\label{alg:g-set}
\begin{algorithmic}[1]
\State let state $s:=$ set $A$\Comment{initally, $\varnothing$}
\Procedure{add}{element $e$}
    \State $A = A \cup \{e\}$
\EndProcedure
\Procedure{lookup}{element $e$}
    \If{$(e \in A)$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{compare}{states $s$, $s'$}
    \If{$s.A \subseteq s'.A$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{states $s$, $s'$}
    \State let state $s'' := \varnothing$
    \State $s''.A = s.A \cup s'.A$
    \State\Return $s''$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Specification \ref{alg:g-set} shows the state-based approach, where the \textit{add}
operation modifies the local state through union. A partial order on some state $s$ and
$s'$ can be defined as $s \leq s' \Leftrightarrow s \subseteq s'$. Conversely, the
\textit{merge} operation between two states returns the union of their respective sets.
The G-Set constitutes a basic building block of more complex implementations, such as the
\textit{2P-Set}

\subsection{Two-Phase Set (2P-Set)}

The 2P-Set is an extension of the G-Set with removal capability. It is formed by
combining two G-Sets, which are used to keep track of added and removed elements.

\begin{algorithm}[bt!]
\caption{State-based Two-Phase Set (2P-Set)}
\label{alg:2p-set}
\begin{algorithmic}[1]
\State let state $s:=$ sets $A,R$\Comment{initally, $\{\varnothing,\varnothing\}$}
\Procedure{lookup}{element $e$}
    \If{$(e \in A)$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{add}{element $e$}
    \State $A = A \cup \{e\}$
\EndProcedure
\Procedure{remove}{element $e$}
    \State \textbf{precondition} \Call{lookup}{$e$}
    \State $R = R \cup \{e\}$
\EndProcedure
\Procedure{compare}{states $s$, $s'$}
    \If{$s.A \subseteq s'.A \vee s.R \subseteq s'.R$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{states $s$, $s'$}
    \State let state $s'' := \{\varnothing, \varnothing\}$
    \State $s''.A = s.A \cup s'.A$
    \State $s''.R = s.R \cup s'.R$
    \State\Return $s''$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Specification \ref{alg:2p-set} shows an example of a state-based 2P-Set implementation.
Similar to what occurs with PN-Counters, the two G-Sets of the 2P-Set keep track
separately of \textit{add} and \textit{remove} operations, and the \textit{merge}
operation returns a new state resulting from the union of each set individually.
It is worth noting that a critical issue may arise when a \textit{remove} operation is
attempted for an element $e$ that does not currently exist in the set. As a consequence,
the \textit{remove} operation requires -- as a precondition -- that $e$ already belongs
to the set, before removing it.

\subsection{Last-Writer-Wins element Set (LWW-element-Set)}

An alternative approach to the 2P-Set can be obtained by applying the
\textit{last-writer-wins} semantic. Aside from having separate sets for keeping track of
added and removed elements, each element has a timestamp associated to it. As a
consequence, the \textit{lookup} operation ensures that a given element $e$ is in the set
if it is in $A$ and it is not in $R$ with a higher timestamp
\cite{shapiro2011comprehensive}:
$$lookup(e) = \exists t, \forall t' > t: (e,t) \in A \wedge (e,t') \notin R$$

\subsection{Observed-Remove Set (OR-Set)}

A more intuitive construction of set CRDT can be obtained by considering
\textit{add-wins} semantics. Simply put, a situation in which an \textit{add} and a
\textit{remove} operation on the same element $e$ occur concurrently results in the
outcome of $e$ being in the set \cite{shapiro2011conflict} -- \textit{add($e$)} "wins"
over \textit{remove($e$)}.

For the \textit{OR-Set}, this means that concurrency strictly depends on causal delivery.
An operation that cancels another will cancel the operations in its causal past, but not
the ones that are being concurrently issued \cite{almeida2024crdts}.

\begin{algorithm}
    \floatname{specification}{Specification}
    \caption{Op-based Observed-Remove Set (OR-Set)}\label{alg:or-set}
    \begin{algorithmic}[1]
        \State let state $s$ := set $S$ of pairs $(\text{element }e,\text{unique ID }U)$
        \Comment{initially, $\varnothing$}
        \Procedure{lookup}{element $e$}
            \If{$\exists U: (e, U)\in S$}
                \State\Return true
            \Else
                \State\Return false
            \EndIf
        \EndProcedure
        \Procedure{add}{element $e$}
            \State \textbf{prepare} ($e$)
                \State\hspace{\algorithmicindent}
                let $\alpha = unique()$\Comment{$unique()$ returns an unique ID}
            \State \textbf{effect} ($e,\alpha$)
                \State\hspace{\algorithmicindent}
                $S = S \cup \{(e,\alpha)\}$
        \EndProcedure
        \Procedure{remove}{element $e$}
            \State \textbf{prepare} ($e$) 
                \State\hspace{\algorithmicindent}
                \textbf{precondition} \Call{lookup}{$e$}
                \State\hspace{\algorithmicindent}
                let $R = \{(e,U)|\exists U: (e,U)\in S\}$
            \State \textbf{effect}($R$)
                \State\hspace{\algorithmicindent}
                \textbf{precondition}
                $\forall(e,U)\in R: add(e,U)\text{ has been delivered}$
                \State\hspace{\algorithmicindent}
                $S = S \setminus R$\Comment{remove pairs observed at source}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

Specification \ref{alg:or-set} illustrates an op-based implementation of OR-Set CRDT,
where the \textit{add} operation always ensures to add an element to the set associating
it with a fresh unique identifier $U$. This ensures that the \textit{remove} operation is
capable of retrieving all unique identifiers associated to the element $e$ which is
target of removal -- more precisely, all the unique identifiers for the element $e$ that
are causally observed at the source replica -- and issue removal for those specific
entries, ensuring preservation of causality \cite{shapiro2011comprehensive}. The unique
tagging ensures that concurrent adds create distinct entries.


\section{Maps}

A \textit{map} is a data type that maps keys to objects. It typically provides a
$put(k,o)$ operation to associate key $k$ to object $o$, and a $remove(k)$ operation to
that removes the mapping for key $k$. Defining suitable concurrency semantics for maps is
crucial, as decisions must be made regarding the outcome of concurrent \textit{put}
operations for the same key, or concurrent \textit{remove} and \textit{put} operations on
the same key \cite{pregui√ßa2018conflict}.

\subsection{Observed-Remove Map (OR-Map)}

\begin{algorithm}[b!]
    \floatname{specification}{Specification}
    \caption{Op-based Observed-Remove Map (OR-Map)}\label{alg:or-map}
    \begin{algorithmic}[1]
        \State let state $s$ := set $S$ of triplets (key $k$, value $v$, unique ID $U$)
        \Comment{initially, $\varnothing$}
        \Procedure{put}{key $k$, value $v$}
            \State \textbf{prepare} ($k,v$)
                \State\hspace{\algorithmicindent}
                let $\alpha = unique()$\Comment{$unique()$ returns an unique ID}
                \State\hspace{\algorithmicindent}
                let $R = \{(k',v',U')\in S | k'=k\}$
            \State \textbf{effect} ($k,v,\alpha,R$)
                \State\hspace{\algorithmicindent}
                \textbf{precondition}
                $\forall(k,v,U)\in R: put(k,v,U)\text{ has been delivered}$
                \State\hspace{\algorithmicindent}
                $S = (S \setminus R) \cup \{(k,v,\alpha)\}$
                \Comment{Replace elements observed at source by new one}
        \EndProcedure
        \Procedure{remove}{key $k$}
            \State \textbf{prepare} ($k$) 
                \State\hspace{\algorithmicindent}
                let $R = \{(k',v',U') \in S| k'=k\}$
            \State \textbf{effect}($R$)
                \State\hspace{\algorithmicindent}
                \textbf{precondition}
                $\forall(k,v,U)\in R: put(k,v,U)\text{ has been delivered}$
                \State\hspace{\algorithmicindent}
                $S = S \setminus R$\Comment{remove elements observed at source}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

We can define a map CRDT with semantics similar to the ones already observed for OR-Sets.
In this case, the payload is formed by a set of triplets (key $k$, value $v$, unique ID
$U$). The $put(k,v)$ operation associates key $k$ to value $v$, tagging it with a fresh
identifier. $remove(k)$ deletes all existing mappings associated to key $k$.
Specification \ref{alg:or-map} shows an example of a naive op-based implementation
\cite{shapiro2011comprehensive}, where the set of unique identifiers that are un-mapped
in the $remove(k)$ operation are retrieved at the source replica.

\section{Lists (Sequences)}

We will now discuss one of the most complex data types, which is the \textit{list} -- or
\textit{sequence} -- which is essentially a set of elements which are placed in a
precise order. Indeed, the challenge in designing a suitable CRDT for this structure is
the necessity of preserving insertion order across concurrent edits.

\subsection{Operation-based RGA (Replicated Growable Array)}

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}: Each list element is assigned a unique identifier
(typically a timestamp or logical clock value paired with replica ID). Elements are
stored with explicit pointers to their predecessor element.

\textit{Insert operation}: $\text{insert}(\text{value}, \text{after.id})$ creates a new
element with a unique ID and links it after the element identified by $\text{after.id}$.
The operation is broadcast with the value, new ID, and predecessor ID.

\textit{Convergence strategy}:

\begin{itemize}
    \item \textit{Causal ordering}: The predecessor reference ensures causal dependency
    -- an insert after element $X$ requires $X$ to exist.
    \item \textit{Concurrent insert resolution}: When multiple elements are concurrently
    inserted after the same predecessor, they are ordered deterministically by comparing
    their unique IDs (e.g., lexicographically).
    \textit{Commutativity}: Insert operations commute because the deterministic ordering
    of concurrent inserts produces the same final sequence regardless of delivery order.
\end{itemize}

\textit{Tombstone mechanism}: Deletions mark elements as removed (tombstones) rather than
physically deleting them, preserving the reference structure for future inserts.

\subsection{WOOT (WithOut Operational Transformation)}

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}: Each character has a unique ID formed by combining
$(\text{site.id}, \text{logical.clock})$. Characters store both their previous and next
character IDs, forming a linked structure.

\textit{Insert operation}: To insert character $C$ between $A$ and $B$, the operation
specifies $\text{insert}(C, \text{prev.id}=A, \text{next.id}=B)$. The insertion is valid
only if $A$ appears before $B$ in the current sequence.

\textit{Concurrent insert ordering}: When multiple characters are inserted between the
same $A$ and $B$:

\begin{itemize}
    \item The algorithm uses the unique IDs to establish a total order among concurrent
    inserts
    \item Characters are positioned based on lexicographic comparison of their IDs
\end{itemize}

\textit{Convergence proof}: The algorithm maintains the invariant that the relative order
of any two characters eventually stabilizes. The integration function is deterministic
and produces the same ordering given the same set of operations.

\subsection{Logoot}

\subsubsection{SEC Compliance Mechanism}

\textit{Position identifiers}: Instead of tombstones and predecessor references, Logoot
assigns each element a position identifier from a dense total order (e.g., rational
numbers or variable-length identifiers with base-N encoding).

\textit{Insert operation}: To insert between positions $P_1$ and $P_2$, generate a new
identifier $P$ such that $P_1 < P < P_2$. The density of the identifier space ensures
this is always possible.

\textit{Merge operation}: Sort all elements by their position identifiers. Since
identifiers form a total order, all replicas converge to the same sequence.

\textit{Concurrent insert handling}: Concurrent inserts between the same positions
receive different identifiers (incorporating replica ID), which are then ordered
deterministically.

\textit{Advantages}: No tombstones required (deletions simply remove elements),
simplifying garbage collection.

\textit{Challenge}: Identifier length can grow over time with repeated insertions between
the same positions (addressed in Logoot-Split and LSEQ variants).

\subsection{Treedoc}

\subsubsection{SEC Compliance Mechanism}

\textit{Binary tree structure}: Elements are organized in a binary tree where in-order
traversal yields the sequence. Each element's position is identified by its path in the
tree.

\textit{Insert operation}: New elements are inserted as children in the tree, with path
disambiguation using replica IDs for concurrent inserts.

\textit{Convergence}: The tree structure and deterministic path comparison ensure all
replicas construct the same tree (and thus the same in-order traversal) given the same
set of operations.

\subsection{Differences between different Sequence CRDT implementations}

\textit{RGA and WOOT}: Rely on tombstones to preserve causal structure; suitable for
applications with moderate deletion rates

\textit{Logoot family}: Avoid tombstones using dense position identifiers; better for
high deletion rates but face identifier growth challenges

\textit{Treedoc}: Tree-based approach balances memory and complexity; may require
rebalancing strategies

\section{Frameworks for general use}

\subsection{Yjs}

\subsection{Automerge}


