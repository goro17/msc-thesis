\chapter{Survey of common CRDT implementation and frameworks}

This chapter provides a systematic survey of Conflict-free Replicated Data Type (CRDT)
implementations documented in academic literature, examining how data structures of
varying complexity -- registers, counters, sets, maps, lists -- are designed to achieve
state convergence. Each data structure is supported by a set of semantics that model the
system's behavior in the face of concurrent operations.

We then conclude with an examination of a few production-grade CRDT frameworks tailored
for general use, such as \textit{Automerge} and \textit{Yjs}, and illustrate their
underlying algorithmic foundations, bridging theoretical formulations with practical
distributed systems engineering. The latter will also constitute the backbone of the
Proof-of-Concept we will discuss in the following chapter.

\section{Registers}

A \textit{register} is an object that holds an opaque value, that supports a
\textit{write} operation to update its value, and a \textit{read} operation to query it.
Concurrent operations writing to the same register require safeguard measures to be
adopted, which comes in the form of two rules, each supporting their own CRDT
implementation, the \textit{Last-Writer-Wins Register} (LWW-Register) and the
\textit{Multi-Value Register} (MV-Register) \cite{shapiro2011comprehensive}.

\subsection{Last-Writer-Wins Register (LWW-Register)}

The LWW-Register represents the simplest form CRDT implementation. It is formed by a
single value, with a timestamp associated to it; the timestamp's presence is due to how
the \textit{last-writer-wins} rule is applied. Given two conflicting states, $s_1$ and
$s_2$, which are affected by concurrent updates, the CRDT's \textit{merge} operation is
applied as follows: $$\text{merge}(s_1,s_2) = \text{max}(s_1\text{.timestamp},
s_2\text{.timestamp})$$

\begin{algorithm}[tb]
\caption{State-based Last-Writer-Wins Register (LWW-Register)}
\label{alg:lww-register}
\begin{algorithmic}[1]
\State let state $s:=$ (value $x$, timestamp $t$)\Comment{initially $(\perp, 0)$}

\Procedure{update}{value $x'$}
    \State $s.x = x'$
    \State $s.t = now()$
\EndProcedure
\Procedure{query}{ }
    \State\Return $s.x$
\EndProcedure
\Procedure{compare}{states $s$, $s''$}
    \If{$s.t\leq s'.t$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{states $s$, $s'$}
    \State let state $s'' := (\perp,0)$
    \If{$s\leq s'$}\Comment{\Call{compare}{$s,s'$}}
        \State $s''.x,s''.t = s'.x,s'.t$
    \Else
        \State $s''.x,s''.t = s.x,s.t$
    \EndIf
    \State\Return s''
\EndProcedure
\end{algorithmic}
\end{algorithm}

The merge operation compares the timestamp from each update and retains the
replica with the highest timestamp. This forms a semilattice where the partial
order is defined by timestamp comparison, ensuring deterministic convergence regardless
of message delivery order. A high-level state-based LWW-Register
\cite{shapiro2011comprehensive} implementation can be found in specification
\ref{alg:lww-register}.


\subsection{Multi-Value Register (MV-Register)}

Made popular by Amazon's Dynamo \cite{decandia2007dynamo} key-value store, Multi-Value
Register CRDTs take a different approach to concurrency with respect to the LWW-Register.
Rather than discarding values based on their timestamp, MV-Registers maintain all
concurrently written values. In this case, the payload is formed by a set
$S$ of values, each with their associated causal context (e.g., vector clock or version
vector).

\begin{algorithm}[tb]
\caption{State-based Multi-Value Register (MV-Register)}
\label{alg:mv-register}
\begin{algorithmic}[1]
\State let state $s:=$ set $X$\Comment{
    $X$: set of $(x, V)$ pairs of value $x$ and version vector $V$
    (initially, $\{(\perp,[0,..,0])\}$)
}

\Procedure{update}{set $R$}
    \State let $V' :=$ \Call{increaseVersionVector}{ }
    \State $s.X = R \times \{V'\}$
\EndProcedure
\Procedure{query}{ }
    \State\Return $r.X$
\EndProcedure
\Procedure{compare}{sets $A$, $B$}
    \If{$(\forall(x,V) \in A, (x',V') \in B: V \leq V')$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{sets $A$, $B$}
    \State let $A' := \{(x,V)\in A|\forall(y,W)\in B: V||W \vee V \geq W\}$
    \State let $B' := \{(y,W)\in B|\forall(x,V)\in A: W||V \vee W \geq V\}$
    \State let $C := A \cup B$
    \State\Return $C$
\EndProcedure
\end{algorithmic}
\end{algorithm}

As shown in specification \ref{alg:mv-register}, the \textit{query} operation returns a
copy of the payload, while the \textit{update} operation overwrites it by associating the
value to a "fresh" version vector that dominates all previous ones. The \textit{merge}
operation returns the union. Compared to its LWW-Register counterpart, the \textit{merge}
operation acts by preserving all concurrent values in the set
\cite{shapiro2011comprehensive} -- in other words, a merge between two conflicting sets
returns a union of every element in each input set whose version vector is not dominated
by the one associated to an element in the other input set.


\section{Counters}

A \textit{counter} is an integer object supporting both \textit{increment} and
\textit{decrement} operations to update its value, and a \textit{read} operation to query
the current value. Trivially, we can construct an operation-based counter CRDT in its
simplest form by propagating update operations as-is. Given that both addition and
subtraction operations commute, the delivery order of concurrent operations is
irrelevant for achieving convergence \cite{shapiro2011comprehensive} -- as long as no
overflow is caused by such operation.

\subsection{Grow-only Counter (G-Counter)}

The simplest form of state-based counter CRDT is the \textit{G-Counter}, which only
supports \textit{increment} operations. For this purpose, each replica $i$ maintains a
vector $V[1..n]$, where $V[i]$ represents the local increment count and $V[j]$ (for
$j \neq i$) represents the last known count from replica $j$
\cite{shapiro2011comprehensive}. This implementation is shown in specification
\ref{alg:g-counter}.

\begin{algorithm}[tb]
\caption{State-based Grow-only Counter (G-Counter)}
\label{alg:g-counter}
\begin{algorithmic}[1]
\State let state $s:=$ vector $V[i_1,..,i_n]$ (where $n$: number of replicas)
    \Comment{initally, $[0,..,0]$}
\Procedure{increment}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $V[g]=V[g]+1$
\EndProcedure
\Procedure{query}{ }
    \State\Return $\sum_i V[i]$
\EndProcedure
\Procedure{compare}{vectors $X$, $Y$}
    \If{$\forall i \in [0,n-1]: X[i] \leq Y[i]$}
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{vectors $X$, $Y$}
    \State let vector $Z := [0,..,0]$
    \State $\forall i \in [0,n-1]: Z[i] = \text{max}(X[i],Y[i])$
    \State\Return Z
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Positive-Negative Counter (PN-Counter)}

In effort to support decrement operations, the PN-Counter is designed by combining two
G-Counters. This CRDT's implementation is therefore formed by a compound payload of two
integer vectors, one to keep track of increments ($P$), while the other to keep track of
decrements ($N$) \cite{shapiro2011comprehensive}.

\begin{algorithm}[tb]
\caption{State-based Positive-Negative Counter (PN-Counter)}
\label{alg:pn-counter}
\begin{algorithmic}[1]
\State let state $s:=$ Payload $(P[i_1,..,i_n],N[i_1,..,i_n])$ (where $n$: number of replicas)
    \Comment{initally, $([0,..,0],[0,..,0])$}
\Procedure{increment}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $P[g]=P[g]+1$
\EndProcedure
\Procedure{decrement}{ }
    \State let $g := localID()$\Comment{$g$: source replica}
    \State $N[g]=N[g]+1$
\EndProcedure
\Procedure{query}{ }
    \State\Return $\sum_i P[i] - \sum_i N[i]$
\EndProcedure
\Procedure{compare}{payloads $X$, $Y$}
    \If{
        $\forall i \in [0,n-1]: X.P[i] \leq Y.P[i] 
         \wedge \forall i \in [0,n-1]: X.N[i] \leq Y.N[i]$
    }
        \State\Return true
    \Else
        \State\Return false
    \EndIf
\EndProcedure
\Procedure{merge}{payloads $X$, $Y$}
    \State let payload $Z := ([0,..,0],[0,..,0])$
    \State $\forall i \in [0,n-1]: Z.P[i] = \text{max}(X.P[i],Y.P[i])$
    \State $\forall i \in [0,n-1]: Z.N[i] = \text{max}(X.N[i],Y.N[i])$
    \State\Return Z
\EndProcedure
\end{algorithmic}
\end{algorithm}

Specification \ref{alg:pn-counter} illustrates this state-based implementation, with
\textit{increment} and \textit{decrement} operations affecting separate vectors of the
state's payload. The \textit{query} operation returns the counter's value by computing
the difference between the $P$ and $N$ vectors, while the \textit{merge} operation
independently merges the two vectors using component-wise maximum.

\section{Sets}

\subsection{Grow-Only Set (G-Set)}
The G-Set permits only element additions, representing the simplest set CRDT.

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}: A set $S$ of elements.

\textit{Add operation}: $\text{add}(e)$ computes $S := S \cup {e}$.

\textit{Merge operation}: Set union $\text{merge}(S_1, S_1) = S_1 \cup S_2$.

\textit{Lattice structure}: Set union forms a join-semilattice under set inclusion
($\subseteq$), where union is the least upper bound operation. Commutativity and
idempotence are immediate from set theory properties.

\subsection{Two-Phase Set (2P-Set)}
The 2P-Set extends G-Set with removal capability by maintaining separate added and
removed sets.

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}: Two G-Sets: $A$ (added elements) and $R$ (removed
elements).

\textit{Operations}:

\begin{itemize}
    \item $\text{add}(e)$ adds to $A$: $A := A \cup {e}$
    \item $\text{remove}(e)$ adds to $R$ if $e \in A$: $R := R \cup {e}$
\end{itemize}

\textit{Membership query}: $e \in set \Leftrightarrow e \in A \wedge e \notin R$ (removed
elements dominate).

\textit{Merge operation}: Independently merge $A$ and $R$ using set union.

\textit{Convergence}: Both $A$ and $R$ are G-Sets (monotonic semilattices), and their
product forms a semilattice. The semantic rule "removed dominates added" provides
deterministic convergence.

\text{Limitation}: Elements cannot be re-added after removal (tombstone accumulation).

\subsection{Last-Write-Wins Element Set (LWW-Element-Set)}

To enable repeated add/remove cycles, the LWW-Element-Set associates timestamps with
operations.

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}:

\begin{itemize}
    \item $A$: Map from elements to add-timestamps
    \item $R$: Map from elements to remove-timestamps
\end{itemize}

\textit{Operations}:

\begin{itemize}
    \item $\text{add}(e, t)$ updates $A[e] := t$
    \item $\text{remove}(e, t)$ updates $R[e] := t$
\end{itemize}

\textit{Membership query}: $e \in set \Leftrightarrow A[e] > R[e]$ (comparing timestamps,
with tie-breaking favoring adds or removes based on bias specification).

\textit{Merge operation}: For each element $e$, take maximum timestamps independently for
$A$ and $R$.

\textit{Convergence}: Timestamp comparison creates a total order (with tie-breaking),
ensuring deterministic convergence through the max-semilattice structure.

\subsection{Observed-Remove Set (OR-Set)}
The OR-Set provides add-wins semantics while preserving causality, avoiding the timestamp
reliance of LWW-Element-Set.

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}: Each element occurrence receives a unique identifier
(UID). The set stores tuples (element, UID).

\textit{Add operation}: add(e) generates a fresh unique tag $u$ and adds $(e, u)$ to the
set.

\textit{Remove operation}: $\text{remove}(e)$ removes all observed $(e, u)$ pairs for
element $e$. The operation includes the specific UIDs to remove, ensuring causality
preservation.

\textit{Membership query}: $e \in set \Leftrightarrow \exists u : (e, u) \in set$.

\textit{Merge operation}: Set union of all $(\text{element}, \text{UID})$ pairs.

\textit{Convergence mechanism}: The unique tagging ensures that concurrent adds create
distinct entries. Remove operations causally depend on prior add observations, preventing
premature deletion. The monotonic growth of unique pairs (modulo causally-justified
removals) ensures convergence.

\textit{Causal consistency}: Remove operations are transmitted with the set of UIDs being
removed, ensuring that only causally observed additions are deleted.

\section{Maps}

Map CRDTs compose key-value pairs where values are themselves CRDTs, enabling nested
conflict resolution.

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}: A mapping from keys to CRDT values:
$M: \text{Key} \rightarrow \text{CRDTValue}$.

\textit{Operations}:

\begin{itemize}
    \item $\text{update}(k, \text{operation})$ applies the specified CRDT operation to
    $M[k]$
    \item $\text{remove}(k)$ deletes the key (implementation-dependent semantics)
\end{itemize}

\textit{Merge operation}: For each key present in either replica:

\begin{itemize}
    \item If key exists in both: merge the CRDT values using their respective merge
    functions
    \item If key exists in only one replica: include that key-value pair (treating
    absence as a bottom element in the lattice)
\end{itemize}

\textit{Convergence}: Since each value is a CRDT with its own convergence guarantee, and
the merge operates key-wise, the composite structure inherits SEC properties. The map
structure forms a product lattice over the individual value lattices.

\textit{Nested composition}: Maps can contain other maps, counters, sets, etc., creating
arbitrarily complex convergent structures.

\textit{Remove Semantics Variants}:

\begin{itemize}
    \item \textit{LWW-Map}: Associates timestamps with key presence/absence
    \item \textit{OR-Map}: Uses unique tokens for key-value pairs, analogous to OR-Set
    \item \textit{RGA-Map}: Applies Replicated Growable Array semantics for ordered key
    spaces
\end{itemize}

\section{Lists (Sequences)}

List CRDTs present the most complex implementation challenge due to the necessity of
preserving insertion order across concurrent edits.

\subsection{Operation-based RGA (Replicated Growable Array)}

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}: Each list element is assigned a unique identifier
(typically a timestamp or logical clock value paired with replica ID). Elements are
stored with explicit pointers to their predecessor element.

\textit{Insert operation}: $\text{insert}(\text{value}, \text{after.id})$ creates a new
element with a unique ID and links it after the element identified by $\text{after.id}$.
The operation is broadcast with the value, new ID, and predecessor ID.

\textit{Convergence strategy}:

\begin{itemize}
    \item \textit{Causal ordering}: The predecessor reference ensures causal dependency
    -- an insert after element $X$ requires $X$ to exist.
    \item \textit{Concurrent insert resolution}: When multiple elements are concurrently
    inserted after the same predecessor, they are ordered deterministically by comparing
    their unique IDs (e.g., lexicographically).
    \textit{Commutativity}: Insert operations commute because the deterministic ordering
    of concurrent inserts produces the same final sequence regardless of delivery order.
\end{itemize}

\textit{Tombstone mechanism}: Deletions mark elements as removed (tombstones) rather than
physically deleting them, preserving the reference structure for future inserts.

\subsection{WOOT (WithOut Operational Transformation)}

\subsubsection{SEC Compliance Mechanism}

\textit{State representation}: Each character has a unique ID formed by combining
$(\text{site.id}, \text{logical.clock})$. Characters store both their previous and next
character IDs, forming a linked structure.

\textit{Insert operation}: To insert character $C$ between $A$ and $B$, the operation
specifies $\text{insert}(C, \text{prev.id}=A, \text{next.id}=B)$. The insertion is valid
only if $A$ appears before $B$ in the current sequence.

\textit{Concurrent insert ordering}: When multiple characters are inserted between the
same $A$ and $B$:

\begin{itemize}
    \item The algorithm uses the unique IDs to establish a total order among concurrent
    inserts
    \item Characters are positioned based on lexicographic comparison of their IDs
\end{itemize}

\textit{Convergence proof}: The algorithm maintains the invariant that the relative order
of any two characters eventually stabilizes. The integration function is deterministic
and produces the same ordering given the same set of operations.

\subsection{Logoot}

\subsubsection{SEC Compliance Mechanism}

\textit{Position identifiers}: Instead of tombstones and predecessor references, Logoot
assigns each element a position identifier from a dense total order (e.g., rational
numbers or variable-length identifiers with base-N encoding).

\textit{Insert operation}: To insert between positions $P_1$ and $P_2$, generate a new
identifier $P$ such that $P_1 < P < P_2$. The density of the identifier space ensures
this is always possible.

\textit{Merge operation}: Sort all elements by their position identifiers. Since
identifiers form a total order, all replicas converge to the same sequence.

\textit{Concurrent insert handling}: Concurrent inserts between the same positions
receive different identifiers (incorporating replica ID), which are then ordered
deterministically.

\textit{Advantages}: No tombstones required (deletions simply remove elements),
simplifying garbage collection.

\textit{Challenge}: Identifier length can grow over time with repeated insertions between
the same positions (addressed in Logoot-Split and LSEQ variants).

\subsection{Treedoc}

\subsubsection{SEC Compliance Mechanism}

\textit{Binary tree structure}: Elements are organized in a binary tree where in-order
traversal yields the sequence. Each element's position is identified by its path in the
tree.

\textit{Insert operation}: New elements are inserted as children in the tree, with path
disambiguation using replica IDs for concurrent inserts.

\textit{Convergence}: The tree structure and deterministic path comparison ensure all
replicas construct the same tree (and thus the same in-order traversal) given the same
set of operations.

\subsection{Differences between different Sequence CRDT implementations}

\textit{RGA and WOOT}: Rely on tombstones to preserve causal structure; suitable for
applications with moderate deletion rates

\textit{Logoot family}: Avoid tombstones using dense position identifiers; better for
high deletion rates but face identifier growth challenges

\textit{Treedoc}: Tree-based approach balances memory and complexity; may require
rebalancing strategies

\section{Frameworks for general use}

\subsection{Yjs}

\subsection{Automerge}


