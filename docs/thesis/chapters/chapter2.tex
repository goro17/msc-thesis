\chapter{Fundamentals of Conflict-free Replicated Data Types}

\section{Consistency in Distributed Systems}

Since the early days of networked computing systems, the challenge of maintaining strong
consistency (or \textit{linearizability} \cite{HerlihyW90}) has been a critical research
topic. As distributed systems started spanning across an ever increasing amount of
devices spread over vast geographic locations, ensuring that all the nodes of a system
operate on a coherent shared state at all times becomes a nontrivial task. The complexity
also lies in making sure that these systems are always available and robust to any fault
or partition that the network could be affected to. While traditional approaches to
replication, such as Lamport's state machine \cite{lamport1984using}, achieve consistency by
relying heavily on central coordination mechanisms, the adoption of such approaches
often comes at the cost of higher latency and disruption of availability under network
partitions. This trade-off has been formalized in literature by the CAP
Theorem \cite{brewer2000towards,gilbert2002brewers}, which identifies three key
guarantees sought by distributed systems:

\begin{itemize}
    \item \textit{Consistency} (C): all nodes of the systems are up to date with the updates
        issued to the internal state. In the context of an atomic read/write register,
        every read operation receives the most recent write -- or an error.
    \item \textit{Availability} (A): every request received by a non-failing node must
        result in a response.
    \item \textit{Partition tolerance} (P): the system continues to operate despite faulty
        conditions, such as network outages, that lead to arbitrary message loss between
        nodes.
\end{itemize}

Moreover, the CAP Theorem states that it is impossible for a real-world system to
simultaneously guarantee more than two of these three properties.

Since network partitions may always occur, system designers were forced to make explicit
choices about the system's behavior during partitions, by either sacrificing consistency
or availability. As a consequence, two dominant design philosophies emerged, being
\textit{AP} (Availability-Partition tolerance) and \textit{CP} (Consistency-Partition
tolerance) systems. In AP systems, such as Amazon's Dynamo \cite{decandia2007dynamo},
eventual inconsistencies between replicas that may arise during network outages are
tolerated to ensure that the system is kept operational at all times. Conversely, CP
systems -- such as Google's Bigtable \cite{chang2008bigtable} -- prioritize strong
consistency guarantees, and particular measures are adopted to ensure that inconsistent
data is never served, such as affecting the system's availability during partitions.
While replicated systems are geared towards the latter approach, high availability
needs remain interesting from a business standpoint, as "even the slightest outage has
significant financial consequences and impacts customer trust" \cite{decandia2007dynamo}.
For this reason, research was driven towards alternative consistency models, namely those
where the consistency guarantees are relaxed, so that all three properties denoted by the
CAP Theorem could simultaneously co-exist.

One such consistency model, known as \textit{optimistic replication}, addresses
concurrency control among replicas by letting the data be accessed "optimistically"
(without a priori synchronization), propagating the resulting updates in the background,
and fixing conflicts after they happen \cite{saito2005optimistic}.
Another prominent example of weak consistency model, named \textit{eventual consistency}
(EC), allows for replicas to temporarily diverge, but guarantees that, when updates to the
replicas are no longer issued, they will converge to an identical
state \cite{terry1994session}. This model significantly enhances availability and
responsiveness, as operations can proceed without waiting for acknowledgement from other
peers. However, if concurrent updates are not reconciled in a principled manner, replicas may
end up in an inconsistent state, leading to erroneous behavior within the system. An 
alternative approach to conflict resolution has led to the emergence of CRDTs, which provide
a mathematically sound framework for achieving state convergence without the need for
synchronization among replicas \cite{preguiça2018conflict}.

\section{Foundational Concepts on Conflict-free Replicated Data Types}

Conflict-free Replicated Data Types (CRDTs) are abstract data types specifically
engineered for replication across multiple processes in a distributed system. A defining
characteristic of CRDTs is that any replica can be modified without requiring immediate
coordination with other replicas, and replicas that have received the same updates reach
the same state deterministically \cite{shapiro2011conflict}. This property is fundamental
to achieving high availability and low latency in distributed applications.

The advantage of CRDTs lies in their mathematical foundation. Rather than relying on
application-specific conflict resolution logic, they ensure convergence through carefully
designed data structures whose operations satisfy specific algebraic properties.

\subsection{CRDT Operation Semantics}

A CRDT can be implemented as a standard data type, which provides a set of operations,
which usually can be distinguished into two categories \cite{preguiça2018conflict}:

\begin{itemize}
    \item \textit{query} operations, which perform a lookup on the internal state --
        without altering it -- and return a result based on what is observed;
    \item \textit{update} operations, which perform a set of actions that explicitly
        mutate the internal state.
\end{itemize}

As we will see when discussing CRDT implementations, performing an update on a CRDT which
is replicated across $n$ nodes firstly involves updating the state of a single replica --
the one which is directly accessed by the application -- and then propagating the update
to all other nodes of the network. When nodes receive an update, they apply it to their
replica, and autonomously resolve any conflicts that may arise -- in other words, they
\textit{merge} the update with their internal state. Broadly speaking, designing an
effective update operation can be regarded as a complex endeavor, as failure to properly
address the correctness criteria involving the set of operations that form the merged
update may result in compromising the system's convergence guarantees. More precisely,
the implementation of update operations must guarantee convergence by satisfying one or
more of the following key properties:

\begin{itemize}
    \item \textit{commutativity}: the order in which delivered updates are applied to the
        replica does not affect the final outcome;
    \item \textit{associativity}: the order in which merges are grouped does not affect
        the outcome;
    \item \textit{idempotency} -- repeated applications of an update yields the same
        outcome as a single application.
\end{itemize}

In most cases, it is desirable to deal with commutative operations; due to the
reliability of the network, a replica may receive updates out of order, and still be
required to converge to a state that is consistent with all other replicas, once all the
updates are applied.

\subsection{Strong Eventual Consistency}
Convergence in the case of CRDTs is backed by a stronger version of the EC model, known
as \textit{Strong Eventual Consistency} (SEC)\cite{shapiro2011conflict}, which guarantees
that, once all nodes have received the same set of updates, they will (eventually) reach
the same final state. Formally, we can define the following.

\paragraph{Eventual Consistency (EC)} An object is said to be \textit{Eventually Consistent}
if it satisfies the following properties:
\begin{itemize}
    \item \textbf{Eventual delivery:} An update delivered to a replica is eventually delivered
        to all replicas; 
    \item \textbf{Convergence:} Replicas that have delivered the same updates eventually
        converge to an equivalent state; 
    \item \textbf{Termination:} All method executions terminate. 
\end{itemize}

\paragraph{Strong Eventual Consistency (SEC)} An object is said to be
\textit{Strongly Eventually Consistent} if it is Eventually Consistent if it satisfies the
following additional property:
\begin{itemize}
    \item \textbf{Strong Convergence:} Replicas that have delivered the same updates
        converge to an equivalent state.
\end{itemize}

SEC achieves state convergence without requiring complex, ad-hoc conflict resolution logic
to be implemented at the application level. Instead, the "conflict-free" nature is embedded
within the design of the data type itself; concurrent operations are either inherently
commutative or are resolved by a deterministic merge procedure built into the CRDT.

\section{Mathematical foundations of convergence}
We will now describe some notions from order theory that are useful to understand the
mathematical properties behind CRDTs' guarantee of convergence.

\subsection{Partial Order and Semilattices}

A fundamental mathematical structure underlying CRDTs is the join semilattice. Before we
describe the definition of join semilattice, we will provide the definition for what a 
partially ordered set and what a least upper bound is \cite{davey2002introduction}.

\paragraph{Partial Order} A \textit{partially ordered} set -- or \textit{poset} -- is
a set $S$ and a binary relation $\leq$ such that, for all $a,b,c\in S$, the following
conditions hold:

\begin{enumerate}
    \item $a \leq a$ (\textit{reflexivity});
    \item If $a \leq b$ and $b \leq a$, then $a = b$ (\textit{antisymmetry});
    \item If $a \leq b$ and $b \leq c$, then $a \leq c$ (\textit{transitivity}).
\end{enumerate}

A partially ordered set is denoted as $(S, \leq)$.

\paragraph{Least upper bound} A \textit{least upper bound} (LUB) of two elements $a$ and
$b$ in a partially ordered set is an element that satisfies the following conditions.

\begin{enumerate}
    \item The LUB is greater than or equal to both $a$ and $b$. That is,
        $\text{LUB} \geq a$ and $b \text{LUB} \geq b$.
    \item There is no other element $c$, with $a \geq c$ and $b \geq c$, such that $c$ is
        less or equal than the LUB.
\end{enumerate}

Through the LUB, we can also understand the definition of a join. For a partially ordered
set $(S, \leq)$ and two elements $a,b \in S$, the \textit{join} of $a$ and $b$ -- denoted
by $a \sqcup b$, is a LUB of $S$. Fundamentally, the join obeys satisfies three key
properties that are relevant to CRDTs:

\begin{enumerate}
    \item $a \sqcup b = b \sqcup a$ (\textit{commutativity});
    \item $(a \sqcup b) \sqcup c = a \sqcup (b \sqcup c)$ (\textit{associativity});
    \item $a \sqcup a = a$ (\textit{idempotency}).
\end{enumerate}

\paragraph{Join semilattice} A \textit{join semilattice} is a partially ordered set
$(S,\leq)$ where there exists a join $x \sqcup y$ for any $x,y \in S$.

It is also useful to observe that a join semilattice is \textit{monotonic}. That is, for
any $a,b \in S$, $a \lt a \sqcup b$.

The properties of a join semilattice are crucial in ensuring that, regardless of the
order in which updates are merged, the result is always the same and represents a
consistent "join" of the information from all replicas. Moreover, the guarantee of
monotonicity ensures that replicas always "grow forward" through merge operations.

\section{Taxonomy of CRDTs}

The design and implementation of CRDTs primarily follows two distinct strategies for
replication: \textit{state-based} and \textit{operation-based}
\cite{shapiro2011comprehensive}.

\subsection{State-based CRDTs}

State-based CRDTs, also known as convergent replicated data types (CvRDTs), operate on the
principle of replicas exchanging their entire current state. When an update to a replica's
state is issued, the replica first applies the update locally, and then broadcasts the
resulting state to the other replicas. The replicas receiving the updated state apply a
merge operation to combine the received state with their own local state. It is important
to note that the merge operation is both commutative, associative, and idempotent. Thanks
to these guarantees, updates can arrive in any order, and can arrive more than once. As
long as all replicas receive the same updates, they will have an equivalent state.

\subsection{Operation-based CRDTs (CmRDTs)}
Operation-based CRDTs, also known as commutative replicated data types (CmRDTs), take a
different approach. Instead of transmitting the entire updated state, replicas broadcast
the update \textit{operations} themselves as they occur locally. These operations are then
applied locally by the receiving replicas. For CmRDTs to ensure convergence, the operations
must be designed to enforce causal order when applied concurrently. This means that
op-based CRDTs need a deterministic mechanism to determine the order of concurrent
messages.

\subsection{Delta State-based CRDTs}
A significant optimization, particularly for state-based CRDTs, is the concept of
delta-state CRDTs (\textit{$\delta$-CRDTs}). Instead of transmitting the entire state,
$\delta$-CRDTs only need to transmit the incremental changes (or \textit{deltas}) that have
occurred since the last state update. These deltas are then merged at the receiving
replicas. This approach overcomes the limitations of state-based replication, which can
often be computationally expensive if the state object to transmit is large in size.
