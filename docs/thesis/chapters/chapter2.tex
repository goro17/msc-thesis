\chapter{Fundamentals of Conflict-free Replicated Data Types}

\section{Consistency in Distributed Systems}

Since the early days of networked computing systems, the challenge of maintaining strong
consistency (or \textit{linearizability} \cite{HerlihyW90}) has been a critical research
topic. As distributed systems started spanning across an ever increasing amount of
devices spread over vast geographic locations, ensuring that all the nodes of a system
operate on a coherent shared state at all times becomes a nontrivial task. The complexity
also lies in making sure that these systems are always available and robust to any fault
or partition that the network could be affected to. While traditional approaches to
replication, such as Lamport's state machine \cite{lamport1984using}, achieve consistency by
relying heavily on central coordination mechanisms, the adoption of such approaches
often comes at the cost of higher latency and disruption of availability under network
partitions. This trade-off has been formalized in literature by the CAP
Theorem \cite{brewer2000towards,gilbert2002brewers}, which identifies three key
guarantees sought by distributed systems:

\begin{itemize}
    \item \textit{Consistency} (C): all nodes of the systems are up to date with the updates
        issued to the internal state. In the context of an atomic read/write register,
        every read operation receives the most recent write -- or an error.
    \item \textit{Availability} (A): every request received by a non-failing node must
        result in a response.
    \item \textit{Partition tolerance} (P): the system continues to operate despite faulty
        conditions, such as network outages, that lead to arbitrary message loss between
        nodes.
\end{itemize}

Moreover, the CAP Theorem states that it is impossible for a real-world system to
simultaneously guarantee more than two of these three properties.

Since network partitions may always occur, system designers were forced to make explicit
choices about the system's behavior during partitions, by either sacrificing consistency
or availability. As a consequence, two dominant design philosophies emerged, being
\textit{AP} (Availability-Partition tolerance) and \textit{CP} (Consistency-Partition
tolerance) systems. In AP systems, such as Amazon's Dynamo \cite{decandia2007dynamo},
eventual inconsistencies between replicas that may arise during network outages are
tolerated to ensure that the system is kept operational at all times. Conversely, CP
systems -- such as Google's Bigtable \cite{chang2008bigtable} -- prioritize strong
consistency guarantees, and particular measures are adopted to ensure that inconsistent
data is never served, such as affecting the system's availability during partitions.
While replicated systems are geared towards the latter approach, high availability
needs remain interesting from a business standpoint, as "even the slightest outage has
significant financial consequences and impacts customer trust" \cite{decandia2007dynamo}.
For this reason, research was driven towards alternative consistency models, namely those
where the consistency guarantees are relaxed, so that all three properties denoted by the
CAP Theorem could simultaneously co-exist.

One such consistency model, known as \textit{optimistic replication}, addresses
concurrency control among replicas by letting the data be accessed "optimistically"
(without a priori synchronization), propagating the resulting updates in the background,
and fixing conflicts after they happen \cite{saito2005optimistic}.
Another prominent example of weak consistency model, named \textit{eventual consistency}
(EC), allows for replicas to temporarily diverge, but guarantees that, when updates to the
replicas are no longer issued, they will converge to an identical
state \cite{terry1994session}. This model significantly enhances availability and
responsiveness, as operations can proceed without waiting for acknowledgement from other
peers. However, if concurrent updates are not reconciled in a principled manner, replicas may
end up in an inconsistent state, leading to erroneous behavior within the system. An 
alternative approach to conflict resolution has led to the emergence of CRDTs, which provide
a mathematically sound framework for achieving state convergence without the need for
synchronization among replicas \cite{preguiça2018conflict}.

\section{Foundational Concepts on Conflict-free Replicated Data Types}
% TODO: Continue from here

Conflict-free Replicated Data Types (CRDTs) are abstract data types specifically
engineered for replication across multiple processes in a distributed system. A defining
characteristic of CRDTs is that any replica can be modified without requiring immediate
coordination with other replicas \cite{shapiro2011conflict}. This property is fundamental
to achieving high availability and low latency in distributed applications.

\subsection{CRDT Operation Semantics}

A CRDT can be implemented as a standard data type, which provides a set of operations,
which usually can be distinguished into two categories \cite{preguiça2018conflict}:

\begin{itemize}
    \item \textit{query} operations, which perform a lookup on the internal state --
        without altering it -- and return a result based on what is observed;
    \item \textit{update} operations, which perform a set of actions that explicitly
        mutate the internal state.
\end{itemize}

As we will see when discussing CRDT implementations, performing an update on a CRDT which
is replicated across $n$ nodes firstly involves updating the state of a single replica --
the one which is directly accessed by the application -- and then propagating the update
to all other nodes of the network. When nodes receive an update, they apply it to their
replica, and autonomously resolve any conflicts that may arise -- in other words, they
\textit{merge} the update with their internal state. Broadly speaking, designing an
effective update operation can be regarded as a complex endeavor, as failure to properly
address the correctness criteria involving the set of operations that form the merged
update may result in compromising the system's convergence guarantees. More precisely,
the implementation of update operations must guarantee convergence by satisfying one or
more of the following key properties:

\begin{itemize}
    \item \textit{commutativity} -- the order in which delivered updates are applied to
        the replica does not affect the final state.
    \item \textit{associativity} -- % TODO
    \item \textit{idempotency} -- % TODO
\end{itemize}

In most cases, it is desirable to deal with commutative operations; due to the
reliability of the network, a replica may receive updates out of order, and still be
required to converge to a state that is consistent with all other replicas, once all the
updates are applied. % TODO: explain how associativity and idempotency tie into CRDTs.

\subsection{Strong Eventual Consistency}
Convergence in the case of CRDTs is backed by a stronger version of the EC model, known
as \textit{Strong Eventual Consistency} (SEC)\cite{shapiro2011conflict}
% TODO: rewrite it better
, in which two replicas reach the same
final state if they have received the same set of updates.

\paragraph{Eventual Consistency (EC)} An object is said to be \textit{Eventually Consistent}
if it satisfies the following properties:
\begin{itemize}
    \item \textbf{Eventual delivery:} An update delivered to a replica is eventually delivered
        to all replicas; 
    \item \textbf{Convergence:} Replicas that have delivered the same updates eventually
        converge to an equivalent state; 
    \item \textbf{Termination:} All method executions terminate. 
\end{itemize}

\paragraph{Strong Eventual Consistency (SEC)} An object is said to be
\textit{Strongly Eventually Consistent} if it is Eventually Consistent if it satisfies the
following additional property:
\begin{itemize}
    \item \textbf{Strong Convergence:} Replicas that have delivered the same updates
        converge to an equivalent state.
\end{itemize}

SEC achieves state convergence without requiring complex, ad-hoc conflict resolution logic
to be implemented by the developer. Instead, the "conflict-free" nature is embedded within
the design of the data type itself; concurrent operations are either inherently commutative
or are resolved by a deterministic merge procedure built into the CRDT.

\subsection{Mathematical foundations}
% TODO: Define join semilattice, how does it tie into commutativity, associativity,
% idempotency, and how it branches into two approaches for convergence (state-based vs.
% op-based, with delta-state being a hybrid between the two.

\section{State-based vs. Operation-based CRDTs}

The design and implementation of CRDTs primarilys follow two distinct strategies for
replication: \textit{state-based} and \textit{operation-based}
\cite{shapiro2011comprehensive}.

\subsection{State-based CRDTs (CvRDTs)}

State-based CRDTs, also known as convergent replicated data types (CvRDTs), operate on the
principle of replicas exchanging their entire current state. When an update to a replica's
state is issued, the replica first applies the update locally, and then broadcasts the
resulting state to the other replicas. The replicas receiving the updated state employ a
\textit{merge} function to combine the received state with their own local state. for
convergence to be guaranteed, this merge function must possess three key mathematical
properties:

\begin{itemize}
    \item \textbf{Commutativity:} the order in which states are merged does not affect the
        outcome;\\
        \begin{equation}
            \begin{aligned} x \cdot y = y \cdot x \end{aligned} 
        \end{equation}
    \item \textbf{Associativity:} the order in which merges are grouped does not affect the
        outcome;\\
        \begin{equation}
            \begin{aligned} (x \cdot y) \cdot z = x \cdot (y \cdot z) \end{aligned}
        \end{equation}
    \item \textbf{Idempotency:} merging identical states produces the same resulting state
        (even when the merge is repeated multiple times).
        \begin{equation}
            \begin{aligned} x \cdot x = x \end{aligned}
        \end{equation}
\end{itemize}

Thanks to these properties, state-based CRDTs can achieve state convergence among replicas,
as long as the replicas have received the same set of updates.

\subsection{Operation-based CRDTs (CmRDTs)}
Operation-based CRDTs, also known as commutative replicated data types (CmRDTs), take a
different approach. Instead of transmitting the entire updated state, replicas broadcast
the update \textit{operations} themselves as they occur locally. These operations are then
applied locally by the receiving replicas. For CmRDTs to ensure convergence, the operations
must be designed to be commutative when applied concurrently. Furthermore, CmRDTs typically
impose stricter constraints on the underlying communication infrastructure. Guarantees such
as exactly-once delivery and causal delivery of operations are often necessary to ensure
that all operations are applied consistently across replicas.

\subsection{Delta-state CRDTs}
A significant optimization, particularly for state-based CRDTs, is the concept of
delta-state CRDTs (\textit{$\delta$-CRDTs}). Instead of transmitting the entire state,
$\delta$-CRDTs only need to transmit the incremental changes (or \textit{deltas}) that have
occurred since the last state update. These deltas are then merged at the receiving
replicas. This approach overcomes the limitations of state-based replication, which can
often be computationally expensive if the state object to transmit is large in size.
