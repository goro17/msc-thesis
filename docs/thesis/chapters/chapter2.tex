\chapter{Fundamentals of Conflict-free Replicated Data Types}

\section{Consistency in Distributed Systems}

Since the early days of networked computing systems, the challenge of maintaining strong
consistency (or \textit{linearizability} \cite{HerlihyW90}) has been a critical research
topic. As distributed systems started spanning across an ever increasing amount of
devices spread over vast geographic locations, ensuring that all the nodes of a system
operate on a coherent shared state at all times becomes a nontrivial task. The complexity
also lies in making sure that these systems are always available and robust to any fault
or partition that the network could be affected to. While traditional approaches to
replication, such as Lamport's state machine \cite{lamport1984using}, achieve consistency by
relying heavily on central coordination mechanisms, the adoption of such approaches
often comes at the cost of higher latency and disruption of availability under network
partitions. This trade-off has been formalized in literature by the CAP
Theorem \cite{brewer2000towards,gilbert2002brewers}, which identifies three key
guarantees sought by distributed systems:

\begin{itemize}
    \item \textit{Consistency} (C): all nodes of the systems are up to date with the updates
        issued to the internal state. In the context of an atomic read/write register,
        every read operation receives the most recent write -- or an error.
    \item \textit{Availability} (A): every request received by a non-failing node must
        result in a response.
    \item \textit{Partition tolerance} (P): the system continues to operate despite faulty
        conditions, such as network outages, that lead to arbitrary message loss between
        nodes.
\end{itemize}

Moreover, the CAP Theorem states that it is impossible for a real-world system to
simultaneously guarantee more than two of these three properties.

Since network partitions may always occur, system designers were forced to make explicit
choices about the system's behavior during partitions, by either sacrificing consistency
or availability. As a consequence, two dominant design philosophies emerged, being
\textit{AP} (Availability-Partition tolerance) and \textit{CP} (Consistency-Partition
tolerance) systems. In AP systems, such as Amazon's Dynamo \cite{decandia2007dynamo},
eventual inconsistencies between replicas that may arise during network outages are
tolerated to ensure that the system is kept operational at all times. Conversely, CP
systems -- such as Google's Bigtable \cite{chang2008bigtable} -- prioritize strong
consistency guarantees, and particular measures are adopted to ensure that inconsistent
data is never served, such as affecting the system's availability during partitions.
While replicated systems are geared towards the latter approach, high availability
needs remain interesting from a business standpoint, as "even the slightest outage has
significant financial consequences and impacts customer trust" \cite{decandia2007dynamo}.
For this reason, research was driven towards alternative consistency models, namely those
where the consistency guarantees are relaxed, so that all three properties denoted by the
CAP Theorem could simultaneously co-exist.

One such consistency model, known as \textit{optimistic replication}, addresses
concurrency control among replicas by letting the data be accessed "optimistically"
(without a priori synchronization), propagating the resulting updates in the background,
and fixing conflicts after they happen \cite{saito2005optimistic}.
Another prominent example of weak consistency model, named \textit{eventual consistency}
(EC), allows for replicas to temporarily diverge, but guarantees that, when updates to the
replicas are no longer issued, they will converge to an identical
state \cite{terry1994session}. This model significantly enhances availability and
responsiveness, as operations can proceed without waiting for acknowledgement from other
peers. However, if concurrent updates are not reconciled in a principled manner, replicas may
end up in an inconsistent state, leading to erroneous behavior within the system. An 
alternative approach to conflict resolution has led to the emergence of CRDTs, which provide
a mathematically sound framework for achieving state convergence without the need for
synchronization among replicas \cite{preguiça2018conflict}.

\section{Foundational Concepts on Conflict-free Replicated Data Types}

Conflict-free Replicated Data Types (CRDTs) are abstract data types specifically
engineered for replication across multiple processes in a distributed system. A defining
characteristic of CRDTs is that any replica can be modified without requiring immediate
coordination with other replicas, and replicas that have received the same updates reach
the same state deterministically \cite{shapiro2011conflict}. This property is fundamental
to achieving high availability and low latency in distributed applications.

The advantage of CRDTs lies in their mathematical foundation. Rather than relying on
application-specific conflict resolution logic, they ensure convergence through carefully
designed data structures whose operations satisfy specific algebraic properties.

\subsection{CRDT Operation Semantics}

A CRDT can be implemented as a standard data type, which provides a set of operations,
which usually can be distinguished into two categories \cite{preguiça2018conflict}:

\begin{itemize}
    \item \textit{query} operations, which perform a lookup on the internal state --
        without altering it -- and return a result based on what is observed;
    \item \textit{update} operations, which perform a set of actions that explicitly
        mutate the internal state.
\end{itemize}

As we will see when discussing CRDT implementations, performing an update on a CRDT which
is replicated across $n$ nodes firstly involves updating the state of a single replica --
the one which is directly accessed by the application -- and then propagating the update
to all other nodes of the network. When nodes receive an update, they apply it to their
replica, and autonomously resolve any conflicts that may arise -- in other words, they
\textit{merge} the update with their internal state. Broadly speaking, designing an
effective update operation can be regarded as a complex endeavor, as failure to properly
address the correctness criteria involving the set of operations that form the merged
update may result in compromising the system's convergence guarantees. More precisely,
the implementation of update operations must guarantee convergence by satisfying one or
more of the following key properties:

\begin{itemize}
    \item \textit{commutativity}: the order in which delivered updates are applied to the
        replica does not affect the final outcome;
    \item \textit{associativity}: the order in which merges are grouped does not affect
        the outcome;
    \item \textit{idempotency}: repeated applications of an update yields the same
        outcome as a single application.
\end{itemize}

In most cases, it is desirable to deal with commutative operations; due to the
reliability of the network, a replica may receive updates out of order, and still be
required to converge to a state that is consistent with all other replicas, once all the
updates are applied.

\subsection{Strong Eventual Consistency}
Convergence in the case of CRDTs is backed by a stronger version of the EC model, known
as \textit{Strong Eventual Consistency} (SEC)\cite{shapiro2011conflict}, which guarantees
that, once all nodes have received the same set of updates, they will (eventually) reach
the same final state. Formally, we can define the following.

\paragraph{Eventual Consistency (EC)} An object is said to be \textit{Eventually Consistent}
if it satisfies the following properties:
\begin{itemize}
    \item \textbf{Eventual delivery:} An update delivered to a replica is eventually delivered
        to all replicas; 
    \item \textbf{Convergence:} Replicas that have delivered the same updates eventually
        converge to an equivalent state; 
    \item \textbf{Termination:} All method executions terminate. 
\end{itemize}

\paragraph{Strong Eventual Consistency (SEC)} An object is said to be
\textit{Strongly Eventually Consistent} if it is Eventually Consistent if it satisfies the
following additional property:
\begin{itemize}
    \item \textbf{Strong Convergence:} Replicas that have delivered the same updates
        converge to an equivalent state.
\end{itemize}

SEC achieves state convergence without requiring complex, ad-hoc conflict resolution logic
to be implemented at the application level. Instead, the "conflict-free" nature is embedded
within the design of the data type itself; concurrent operations are either inherently
commutative or are resolved by a deterministic merge procedure built into the CRDT.

\section{Mathematical foundations of convergence}
We will now describe some notions from order theory that are useful to understand the
mathematical properties behind CRDTs' guarantee of convergence.

\subsection{Partial Order and Semilattices}

A fundamental mathematical structure underlying CRDTs is the join semilattice. Before we
describe the definition of join semilattice, we will provide the definition for what a 
partially ordered set and what a least upper bound is \cite{davey2002introduction}.

\paragraph{Partial Order} A \textit{partially ordered} set -- or \textit{poset} -- is
a set $S$ and a binary relation $\leq$ such that, for all $a,b,c\in S$, the following
conditions hold:

\begin{enumerate}
    \item $a \leq a$ (\textit{reflexivity});
    \item If $a \leq b$ and $b \leq a$, then $a = b$ (\textit{antisymmetry});
    \item If $a \leq b$ and $b \leq c$, then $a \leq c$ (\textit{transitivity}).
\end{enumerate}

A partially ordered set is denoted as $(S, \leq)$.

\paragraph{Least upper bound} A \textit{least upper bound} (LUB) of two elements $a$ and
$b$ in a partially ordered set is an element that satisfies the following conditions.

\begin{enumerate}
    \item The LUB is greater than or equal to both $a$ and $b$. That is,
        $\text{LUB} \geq a$ and $\text{LUB} \geq b$.
    \item There is no other element $c$, with $a \geq c$ and $b \geq c$, such that $c$ is
        less or equal than the LUB.
\end{enumerate}

Through the LUB, we can also understand the definition of a join. For a partially ordered
set $(S, \leq)$ and two elements $a,b \in S$, the \textit{join} of $a$ and $b$ -- denoted
by $a \sqcup b$, is a LUB of $S$. Fundamentally, the join obeys satisfies three key
properties that are relevant to CRDTs:

\begin{enumerate}
    \item $a \sqcup b = b \sqcup a$ (\textit{commutativity});
    \item $(a \sqcup b) \sqcup c = a \sqcup (b \sqcup c)$ (\textit{associativity});
    \item $a \sqcup a = a$ (\textit{idempotency}).
\end{enumerate}

\paragraph{Join semilattice} A \textit{join semilattice} is a partially ordered set
$(S,\leq)$ where there exists a join $x \sqcup y$ for any $x,y \in S$.

It is also useful to observe that a join semilattice is \textit{monotonic}. That is, for
any $a,b \in S$, $a < a \sqcup b$.

The properties of a join semilattice are crucial in ensuring that, regardless of the
order in which updates are merged, the result is always the same and represents a
consistent "join" of the information from all replicas. Moreover, the guarantee of
monotonicity ensures that replicas always "grow forward" through merge operations, with
respect to state mutation.

\section{Taxonomy of CRDTs}

Before the introduction of a few relevant CRDT implementations in the following chapter,
it is useful to provide a comprehensive taxonomy of CRDT designs, each with its distinct
characteristics with respect to how replicas -- more precisely, updates among replicas --
are synchronized. Fundamentally, these branch into one of two categories,
\textit{state-based} or \textit{operation-based} CRDTs\cite{shapiro2011comprehensive},
with a hybrid approach  -- \textit{delta state-based} CRDTs -- also being viable.

\subsection{State-based CRDTs (CvRDTs)}

State-based CRDTs, also called convergent replicated data types (CvRDTs), operate on
the principle of achieving convergence through propagation of entire states. The source
replica receives an update and applies it locally, and the resulting state is then
propagated to other replicas through a payload. Upon receiving a state, if a replica's
local state and the received state conflict, a deterministic merge operation is applied,
which leads to a new state that reflects the conflict resolution. The overall process
can be described as follows.

\begin{enumerate}
    \item A client invokes an update on a source replica.
    \item The update immediately modifies the local state.
    \item The modified state is asynchronously propagated to other replicas.
    \item Replicas receive the modified state and merge it with their own local state.
\end{enumerate}

As states can be propagated in many ways -- for example, employing an epidemic propagation
algorithm to an unknown set of participants \cite{demers1987epidemic} -- and be delivered
to replicas in any order, the merge operation must be compliant with the constraints
already discussed above -- it must be commutative, associative, idempotent, and
monotonic. Thus, for this approach to work, the replica state must be a join semilattice.

\subsection{Operation-based CRDTs (CmRDTs)}

Operation-based CRDTs, also called commutative replicated data types (CmRDTs), take a
different approach with respect to state-based replication. as the name suggests,
op-based CRDTs rely on achieving convergence by propagating operations to replicas,
rather than propagating entire states.

The process of op-based replication is typically subdivided into two phases.

\begin{enumerate}
    \item A \textit{"prepare"} phase, where the update is firstly applied to the source
        replica.
    \item An \textit{"effect"} phase, where the operations which form the update are
        asynchronously propagated and executed on other replicas.
\end{enumerate}

In order for convergence to occur, a reliable messaging channel must be adopted, which
complies with the constraints dictated by the CmRDT. For instance, operations are, in
general, not idempotent, which implies the adoption of an exactly-once messaging
mechanism. Furthermore, op-based replication typically occurs through causal broadcast
mechanisms \cite{birman1987reliable}, which leads to two or more operations which are
causally dependent to each other to be viewed in the correct order. While CmRDTs are
more complex in design, they provide greater expressive power
\cite{shapiro2011comprehensive}.

\subsection{Delta State CRDTs ($\delta$-CRDTs)}

While state-based and operation-based CRDTs are both successfull in achieving SEC
guarantees, a third approach has also emerged in literature which addresses the
drawbacks of the previous two approaches. On one hand, state-based CRDTs may be
inefficient when the state object is large in size, affecting the bandwidth of the
network. On the other hand, operation-based CRDTs heavily rely on the design of
complex propagation channels that require the guarantees of reliable and causal
communication. \textit{Delta State CRDTs} -- also commonly notated as $\delta$-CRDTs --
evolve from both state-based and operation-based CRDTs. They rely on adopting a simple,
unreliable propagation channel (state-based replication) for the dissemination of
messages that are small in size and of incremental nature (operation-based replication)
\cite{almeida2014efficient}.

While traditional state-based CRDTs rely on issuing state changes via mutator functions
that return the entire modified state, $\delta$-CRDTs rely on \textit{$\delta$-mutators}
which return a value -- or \textit{delta} -- reflecting the incremental changes. The
delta is then propagated and merged with remote replicas to achieve convergence.
